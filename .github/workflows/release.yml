name: Create AI-Powered Release

on:
  workflow_dispatch:
    inputs:
      version_type:
        description: 'The type of version bump (patch, minor, or major)'
        required: true
        type: choice
        options:
          - patch
          - minor
          - major
        default: 'patch'

permissions:
  contents: write
  packages: write

jobs:
  create-release:
    name: Create Release
    runs-on: ubuntu-latest

    steps:
      - name: Check out code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '18'

      - name: Determine Semantic Base and New Version
        id: versioning
        run: |
          npm install semver
          SORTED_TAGS=$(git tag | grep -E '^v[0-9]+\.[0-9]+\.[0-9]+$' | node -e "
              const semver = require('semver');
              const fs = require('fs');
              const tags = fs.readFileSync(0, 'utf-8').split('\n').filter(Boolean);
              console.log(tags.sort(semver.compare).join('\n'));
          ")
          if [ -z "$SORTED_TAGS" ]; then
            LATEST_TAG="v0.0.0" # Set a default if no tags exist
          else
            LATEST_TAG=$(echo "$SORTED_TAGS" | tail -n 1)
          fi
          
          BASE_TAG_FOR_LOG=$LATEST_TAG
          VERSION_TYPE="${{ github.event.inputs.version_type }}"

          if [ "$VERSION_TYPE" == "minor" ]; then
              MAJOR_MINOR_PREFIX=$(echo $LATEST_TAG | cut -d'.' -f1,2)
              FOUND_BASE=$(echo "$SORTED_TAGS" | grep "^${MAJOR_MINOR_PREFIX}\." | head -n 1)
              if [ -n "$FOUND_BASE" ]; then BASE_TAG_FOR_LOG=$FOUND_BASE; fi
          elif [ "$VERSION_TYPE" == "major" ]; then
              MAJOR_PREFIX=$(echo $LATEST_TAG | cut -d'.' -f1)
              FOUND_BASE=$(echo "$SORTED_TAGS" | grep "^${MAJOR_PREFIX}\." | head -n 1)
              if [ -n "$FOUND_BASE" ]; then BASE_TAG_FOR_LOG=$FOUND_BASE; fi
          fi
          
          echo "Release type: $VERSION_TYPE"
          echo "Base tag for changelog: $BASE_TAG_FOR_LOG"
          
          VERSION=$(echo $LATEST_TAG | sed 's/^v//')
          NEW_VERSION=$(npm --no-git-tag-version --allow-same-version=true --version="$VERSION" $VERSION_TYPE)
          NEW_TAG="v$NEW_VERSION"
          
          echo "New tag: $NEW_TAG"
          
          echo "base_tag_for_log=$BASE_TAG_FOR_LOG" >> $GITHUB_OUTPUT
          echo "new_tag=$NEW_TAG" >> $GITHUB_OUTPUT

      - name: Get Commit Log
        id: commit-log
        run: |
          # Use the intelligently determined base tag for generating the log
          echo "Gathering commits between ${{ steps.versioning.outputs.base_tag_for_log }} and HEAD..."
          git log --pretty=format:"- %s (%h)" ${{ steps.versioning.outputs.base_tag_for_log }}..HEAD > changes.txt
          
          # --- START OF THE FIX ---
          # Generate a unique, random string to use as a delimiter.
          # This prevents the content of the log from accidentally closing the multi-line string.
          DELIMITER=$(uuidgen)
          echo "commit_log<<${DELIMITER}" >> $GITHUB_OUTPUT
          cat changes.txt >> $GITHUB_OUTPUT
          echo "${DELIMITER}" >> $GITHUB_OUTPUT

      - name: Generate Changelog Section with Gemini AI
        id: gemini-notes
        run: |
          PROMPT=$(cat <<EOF
          You are an expert technical writer for the Matplobbot project. Your task is to transform a raw git log into a polished, professional changelog section.

          Analyze the following commit log, which contains all changes since version "${{ steps.versioning.outputs.base_tag_for_log }}".

          **Instructions:**
          1.  **Categorize**: Group the changes into logical sections: "âœ¨ New Features", "ðŸ› Bug Fixes", "ðŸš€ Performance & Architectural Improvements", "ðŸ› ï¸ CI/CD & Tooling", "ðŸ“„ Documentation". Omit any empty categories.
          2.  **Rewrite**: Convert the commit messages into clear, human-readable bullet points that explain the *impact* of the change.
          3.  **Summarize**: Begin with a brief, engaging introductory paragraph that highlights the key aspects of this release.
          4.  **Format**: The entire output must be clean markdown. Do NOT include the version header (like ## [v1.2.3]), as the workflow will add this. Just provide the summary paragraph and the categorized bullet points.

          **Raw Git Log to Analyze:**
          ${{ steps.commit-log.outputs.commit_log }}
          EOF
          )
          
          JSON_PAYLOAD=$(jq -n --arg prompt "$PROMPT" \
            '{ "contents": [ { "parts": [ { "text": $prompt } ] } ] }')

          RESPONSE=$(curl -s -H "Content-Type: application/json" \
            -d "$JSON_PAYLOAD" \
            "https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-pro-latest:generateContent?key=${{ secrets.GEMINI_API_KEY }}")

          # We need to escape newlines for sed, so we use jq to create a JSON string and then manipulate it
          NOTES=$(echo $RESPONSE | jq -r '.candidates[0].content.parts[0].text')
          
          echo "AI-Generated Notes:"
          echo "$NOTES"
          echo "notes_for_release<<EOF" >> $GITHUB_OUTPUT
          echo "$NOTES" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
          
          # Prepare notes for sed command by escaping special characters
          ESCAPED_NOTES=$(printf '%s\n' "$NOTES" | sed 's/[&/\]/\\&/g' | sed ':a;N;$!ba;s/\n/\\n/g')
          echo "escaped_notes=$ESCAPED_NOTES" >> $GITHUB_OUTPUT

      - name: Update and Commit CHANGELOG.md
        run: |
          NEW_TAG="${{ steps.versioning.outputs.new_tag }}"
          CURRENT_DATE=$(date +'%Y-%m-%d')
          NEW_RELEASE_HEADER="## [$NEW_TAG] - $CURRENT_DATE"
          UNRELEASED_ANCHOR="## [Unreleased]"
          
          # This sed command inserts the new release header and the AI-generated notes
          # right after the "[Unreleased]" line.
          sed -i "/^${UNRELEASED_ANCHOR}/a \\n${NEW_RELEASE_HEADER}\\n${{ steps.gemini-notes.outputs.escaped_notes }}" CHANGELOG.md
          
          echo "CHANGELOG.md has been updated."
          
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add CHANGELOG.md
          git commit -m "docs(changelog): Update for release ${NEW_TAG}"
          git push

      - name: Create and Push New Git Tag
        run: |
          echo "Creating and pushing tag ${{ steps.versioning.outputs.new_tag }}"
          git tag ${{ steps.versioning.outputs.new_tag }}
          git push origin ${{ steps.versioning.outputs.new_tag }}

      - name: Create GitHub Release
        id: create-release
        uses: actions/create-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: ${{ steps.versioning.outputs.new_tag }}
          release_name: Release ${{ steps.versioning.outputs.new_tag }}
          body: ${{ steps.gemini-notes.outputs.notes_for_release }}
          draft: false
          prerelease: false
