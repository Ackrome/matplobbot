<!DOCTYPE html>
<html lang="ru" data-theme="light">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Статистика Бота</title>
    <style>
        body { font-family: sans-serif; margin: 20px; background-color: #f4f4f4; color: #333; }
        .container { background-color: #fff; padding: 20px; border-radius: 8px; box-shadow: 0 0 10px rgba(0,0,0,0.1); }
        h1 { color: #333; }
        h2 { color: #444; margin-top: 30px;}
        table { width: 100%; border-collapse: collapse; margin-top: 15px; }
        th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }
        th { background-color: #e9e9e9; }
        tbody tr:nth-child(even) { background-color: #f9f9f9; }
        tbody tr:hover { background-color: #f1f1f1; }

        .stat-item { margin-bottom: 10px; padding: 10px; background-color: #e9e9e9; border-radius: 4px; }
        .stat-item strong { color: #555; }
        #loading { color: #777; }
        .charts-container {
            display: flex;
            flex-wrap: wrap; /* Позволит переноситься на новую строку на малых экранах */
            gap: 20px; /* Пространство между графиками */
        }
        .chart-wrapper {
            flex: 1; /* Графики будут стараться занять равное пространство */
            min-width: 300px; /* Минимальная ширина для каждого графика */
            height: 400px; /* Слегка уменьшим высоту предыдущих графиков */
        }
        /* Стили для вкладок */
        .tab-container {
            overflow: hidden;
            border: 1px solid #ccc;
            background-color: #f1f1f1;
            margin-top: 20px;
        }
        .tab-container button {
            background-color: inherit;
            float: left;
            border: none;
            outline: none;
            cursor: pointer;
            padding: 14px 16px;
            transition: 0.3s;
        }
        .tab-container button:hover { background-color: #ddd; }
        .tab-container button.active { background-color: #ccc; }
        .tab-content {
            display: none; /* Скрываем все вкладки по умолчанию */
            padding: 6px 12px;
            /* border: 1px solid #ccc; */ /* Убираем рамку */
            /* border-top: none; */ /* Убираем верхнюю рамку, если она была отдельно */
        }
        /* Базовые стили для области лога бота (применяются для светлой темы по умолчанию) */
        #bot-log-content {
            white-space: pre-wrap;
            word-wrap: break-word;
            max-height: 600px;
            overflow-y: auto;
            padding: 10px;
            border-radius: 4px;
            font-family: 'Courier New', Courier, monospace;
            font-size: 0.9em;
            background-color: #f0f0f0; /* Фон для светлой темы */
            color: #333333;       /* Цвет текста для светлой темы */
            border: 1px solid #ddd; /* Граница для светлой темы */
        }
        /* Стили для переключателя темы */
        .theme-switcher {
            position: absolute;
            top: 20px;
            right: 20px;
            cursor: pointer;
            padding: 8px 12px;
            border-radius: 20px;
            background-color: #e0e0e0;
            color: #333;
            font-size: 0.9em;
            border: 1px solid #ccc;
            user-select: none; /* Предотвратить выделение текста при клике */
        }
        .theme-switcher:hover {
            background-color: #d0d0d0;
        }

        /* Темная тема */
        html[data-theme='dark'] body { background-color: #1e1e1e; color: #e0e0e0; }
        html[data-theme='dark'] .container { background-color: #2a2a2a; box-shadow: 0 0 10px rgba(0,0,0,0.5); }
        html[data-theme='dark'] h1 { color: #e0e0e0; }
        html[data-theme='dark'] h2 { color: #d0d0d0; }
        html[data-theme='dark'] table { border-collapse: collapse; } /* Убедимся, что границы не удваиваются */
        html[data-theme='dark'] th, html[data-theme='dark'] td { border: 1px solid #444; color: #c0c0c0; }
        html[data-theme='dark'] th { background-color: #3a3a3a; }
        html[data-theme='dark'] tbody tr:nth-child(even) { background-color: #333; }
        html[data-theme='dark'] tbody tr:hover { background-color: #404040; }
        html[data-theme='dark'] .stat-item { background-color: #3a3a3a; }
        html[data-theme='dark'] .stat-item strong { color: #b0b0b0; }
        html[data-theme='dark'] #loading { color: #999; }
        html[data-theme='dark'] .tab-container { border: 1px solid #444; background-color: #333; }
        html[data-theme='dark'] .tab-container button { background-color: inherit; color: #c0c0c0; }
        html[data-theme='dark'] .tab-container button:hover { background-color: #444; }
        html[data-theme='dark'] .tab-container button.active { background-color: #555; }
        html[data-theme='dark'] #bot-log-content { background-color: #252525; color: #d0d0d0; border: 1px solid #444; }
        html[data-theme='dark'] #leaderboard-table a { color: #8ab4f8; } /* Цвет ссылок в темной теме */
        html[data-theme='dark'] #leaderboard-table a:hover { color: #a3c5f9; }
        html[data-theme='dark'] .theme-switcher {
            background-color: #4a4a4a;
            color: #e0e0e0;
            border: 1px solid #666;
        }
        html[data-theme='dark'] .theme-switcher:hover {
            background-color: #5a5a5a;
        }
        /* Стили для fallback аватара в темной теме */
        html[data-theme='dark'] .fallback-avatar {
            background-color: #404040 !important; /* Используем !important, если инлайн стили перебивают */
            border: 1px solid #555555 !important;
            color: #c0c0c0 !important;
        }

        /* Стили для лога бота с учетом темы */
        .log-entry .timestamp { color: #888888; }
        html[data-theme='dark'] .log-entry .timestamp { color: #aaaaaa; }

        .log-entry .level { font-weight: bold; padding: 0px 4px; border-radius: 3px; margin-right: 5px; }

        .log-entry .level-info { color: #28a745; } /* Green */
        html[data-theme='dark'] .log-entry .level-info { color: #34c759; } /* Lighter Green */
        .log-entry .message-info { /* Inherits general text color */ }
        html[data-theme='dark'] .log-entry .message-info { /* Inherits general text color */ }

        .log-entry .level-warning { color: #d9a300; } /* Dark Yellow */
        html[data-theme='dark'] .log-entry .level-warning { color: #ffcc00; }
        .log-entry .message-warning { /* Inherits general text color */ }
        html[data-theme='dark'] .log-entry .message-warning { /* Inherits general text color */ }

        .log-entry .level-error { color: #dc3545; } /* Red */
        html[data-theme='dark'] .log-entry .level-error { color: #ff453a; }
        .log-entry .message-error { /* Inherits general text color */ }
        html[data-theme='dark'] .log-entry .message-error { /* Inherits general text color */ }

        .log-entry .level-critical { color: #dc3545; background-color: rgba(220, 53, 69, 0.1); }
        html[data-theme='dark'] .log-entry .level-critical { color: #ff453a; background-color: rgba(255, 69, 58, 0.2); }
        .log-entry .message-critical { font-weight: bold; }
        html[data-theme='dark'] .log-entry .message-critical { font-weight: bold; }

        .log-entry .level-debug { color: #007bff; } /* Blue */
        html[data-theme='dark'] .log-entry .level-debug { color: #0a84ff; }
        .log-entry .message-debug { /* Inherits general text color */ }
        html[data-theme='dark'] .log-entry .message-debug { /* Inherits general text color */ }

        .log-error-unparsed { color: red; }
        html[data-theme='dark'] .log-error-unparsed { color: #ff6b6b; }
    </style>
</head>


<body>
    <div class="container">
        <div class="theme-switcher" id="theme-toggle-button">Сменить тему</div>
         <h1>Статистика Телеграм Бота</h1>
         
        <div id="stats-data">
            <div class="stat-item" id="total-actions-item">
                <strong>Общее количество действий:</strong> <span id="total-actions-value">Подключение...</span>
            </div>

            <!-- Контейнер для вкладок -->
            <div class="tab-container">
                <button class="tab-button active" onclick="openTab(event, 'commandsTab')">Популярные команды</button>
                <button class="tab-button" onclick="openTab(event, 'messagesTab')">Популярные сообщения</button>
                <button class="tab-button" onclick="openTab(event, 'typesTab')">Типы действий</button>
                <button class="tab-button" onclick="openTab(event, 'activityTimeTab')">Активность по времени</button>
                <button class="tab-button" onclick="openTab(event, 'logTab')">Лог Бота</button>
            </div>

            <!-- Содержимое вкладок -->
            <div id="commandsTab" class="tab-content" style="display: block;"> <!-- Первая вкладка активна по умолчанию -->
                <div class="chart-wrapper">
                    <h2>Популярные команды</h2>
                    <canvas id="popularCommandsChart"></canvas>
                    <p id="popular-commands-status" style="text-align:center;"></p>
                </div>
            </div>

            <div id="messagesTab" class="tab-content">
                <div class="chart-wrapper">
                    <h2>Популярные сообщения</h2>
                    <canvas id="popularMessagesChart"></canvas>
                    <p id="popular-messages-status" style="text-align:center;"></p>
                </div>
            </div>

            <div id="typesTab" class="tab-content">
                <div class="chart-wrapper" style="min-width: 300px; max-width: 500px; margin: 20px auto;"> <!-- Центрируем круговую диаграмму -->
                    <canvas id="actionTypesChart" style="height: 400px;"></canvas> <!-- Явно задаем высоту для canvas внутри вкладки -->
                    <p id="action-types-status" style="text-align:center;"></p>
                </div>
            </div>

            <div id="activityTimeTab" class="tab-content">
                <div class="chart-wrapper">
                    <h2>Активность по времени (по дням)</h2>
                    <canvas id="activityOverTimeChart"></canvas>
                    <p id="activity-over-time-status" style="text-align:center;"></p>
                </div>
            </div>

            <div id="logTab" class="tab-content">
                <h2>Лог Бота (в реальном времени)</h2>
                <pre id="bot-log-content">Подключение к логу...</pre>
                <p id="bot-log-status" style="text-align:center;"></p>
            </div>


            <!-- Таблица лидеров теперь ниже -->
            <h2 style="margin-top: 60px;">Таблица лидеров</h2>
            <table id="leaderboard-table">
                <thead>
                    <tr>
                        <th>#</th>
                        <th style="border-right: none;">Аватар</th>
                        <th style="border-left: none; ">Пользователь (Полное имя)</th>
                        <th>Тэг Телеграм</th>
                        <th>Кол-во действий</th>
                        <th>Последнее действие</th>
                    </tr>
                </thead>
                <tbody id="leaderboard-body">
                    <tr><td colspan="6" style="text-align:center;">Загрузка данных...</td></tr>
                </tbody>
            </table>
         </div>
     </div>
 
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
     <script>
        const totalActionsValueElement = document.getElementById('total-actions-value');
        const leaderboardBodyElement = document.getElementById('leaderboard-body');
        const popularCommandsStatusElement = document.getElementById('popular-commands-status');
        const popularMessagesStatusElement = document.getElementById('popular-messages-status');
        const actionTypesStatusElement = document.getElementById('action-types-status');
        const activityOverTimeStatusElement = document.getElementById('activity-over-time-status');
        const botLogContentElement = document.getElementById('bot-log-content');
        const botLogStatusElement = document.getElementById('bot-log-status');
        
        let popularCommandsChartInstance; // Для хранения экземпляра графика
        let popularMessagesChartInstance; // Для графика популярных сообщений
        let actionTypesChartInstance; // Для графика типов действий
        let activityOverTimeChartInstance; // Для графика активности по времени

        let statsSocket;
        let logSocket;

        // Определяем URL для WebSocket. Если используется HTTPS, нужен wss://
        const wsProtocol = window.location.protocol === "https:" ? "wss:" : "ws:";
        const wsHost = window.location.host; // localhost:9583 или ваш домен
        const statsWsUrl = `${wsProtocol}//${wsHost}/ws/stats/total_actions`;
        const logWsUrl = `${wsProtocol}//${wsHost}/ws/bot_log`;
        
        function connectWebSocket() {
            statsSocket = new WebSocket(statsWsUrl);

            statsSocket.onopen = function(event) {
                console.log("WebSocket соединение установлено.");
                totalActionsValueElement.textContent = "Ожидание данных...";
            };
            statsSocket.onmessage = function(event) {
                try {
                    const data = JSON.parse(event.data);
                    if (data.error) {
                        console.error("WebSocket Server Error:", data.error); // Ошибка от сервера
                        totalActionsValueElement.textContent = `Ошибка: ${data.error}`;
                        leaderboardBodyElement.innerHTML = `<tr><td colspan="6" style="text-align:center;">Ошибка: ${data.error}</td></tr>`;
                        popularCommandsStatusElement.textContent = `Ошибка загрузки графика: ${data.error}`;
                        if (popularCommandsChartInstance) { popularCommandsChartInstance.destroy(); popularCommandsChartInstance = null; }
                        popularMessagesStatusElement.textContent = `Ошибка загрузки графика: ${data.error}`;
                        if (popularMessagesChartInstance) { popularMessagesChartInstance.destroy(); popularMessagesChartInstance = null; }
                        actionTypesStatusElement.textContent = `Ошибка загрузки графика: ${data.error}`;
                        if (actionTypesChartInstance) { actionTypesChartInstance.destroy(); actionTypesChartInstance = null; }
                        activityOverTimeStatusElement.textContent = `Ошибка загрузки графика: ${data.error}`;
                        if (activityOverTimeChartInstance) { activityOverTimeChartInstance.destroy(); activityOverTimeChartInstance = null; }
                    } else if (data.total_actions !== undefined) {
                        totalActionsValueElement.textContent = data.total_actions;
                    }

                    if (data.leaderboard && Array.isArray(data.leaderboard)) {
                        leaderboardBodyElement.innerHTML = ''; // Очищаем предыдущие данные
                        if (data.leaderboard.length === 0) {
                            leaderboardBodyElement.innerHTML = `<tr><td colspan="6" style="text-align:center;">Нет данных для отображения.</td></tr>`;
                        } else {
                            data.leaderboard.forEach((user, index) => {
                                const row = leaderboardBodyElement.insertRow();
                                row.insertCell().textContent = index + 1;
                                const avatarCell = row.insertCell();
                                avatarCell.style.width = '76px'; // 60px (image) + 2*8px (padding)
                                avatarCell.style.height = '76px'; // 60px (image) + 2*8px (padding)
                                avatarCell.style.borderRight = 'none';
                                avatarCell.style.textAlign = 'center';
                                avatarCell.style.verticalAlign = 'middle';

                                if (user.avatar_pic_url) {
                                    const img = document.createElement('img');
                                    img.src = user.avatar_pic_url;
                                    img.alt = `Аватар ${user.full_name || user.username}`;
                                    img.style.width = '60px'; // Увеличено
                                    img.style.height = '60px'; // Увеличено
                                    img.style.borderRadius = '50%';
                                    img.onerror = function() {
                                        // Очищаем содержимое ячейки и устанавливаем текст ошибки
                                        avatarCell.innerHTML = ''; // Удаляем сломанный тег img
                                        avatarCell.textContent = 'Ошибка';
                                    };
                                    avatarCell.appendChild(img);
                                } else {
                                    // Отображаем белый круг с первой буквой имени
                                    const fallbackAvatar = document.createElement('div');
                                    fallbackAvatar.style.width = '60px';
                                    fallbackAvatar.style.height = '60px';
                                    fallbackAvatar.style.borderRadius = '50%';
                                    fallbackAvatar.style.backgroundColor = '#ffffff';
                                    fallbackAvatar.style.border = '1px solid #e0e0e0'; // Тонкая граница для круга
                                    fallbackAvatar.style.display = 'flex';
                                    fallbackAvatar.style.alignItems = 'center';
                                    fallbackAvatar.style.justifyContent = 'center';
                                    fallbackAvatar.style.fontSize = '30px';
                                    fallbackAvatar.style.fontWeight = 'bold';
                                    fallbackAvatar.style.color = '#555555'; // Цвет буквы
                                    fallbackAvatar.style.textTransform = 'uppercase';

                                    fallbackAvatar.classList.add('fallback-avatar'); // Добавляем класс для стилизации темной темы
                                    let initial = '?';
                                    if (user.full_name && user.full_name.trim().length > 0) {
                                        initial = user.full_name.trim()[0];
                                    }
                                    fallbackAvatar.textContent = initial;
                                    avatarCell.appendChild(fallbackAvatar);
                                }
                                const fullNameCell = row.insertCell();
                                fullNameCell.style.borderLeft = 'none';
                                // Проверяем, есть ли username и не является ли он заглушкой "Нет username"
                                if (user.username && user.username !== 'Нет username') {
                                    const link = document.createElement('a');
                                    link.href = `https://t.me/${user.username}`;
                                    link.textContent = user.full_name;
                                    link.target = '_blank'; // Открывать в новой вкладке
                                    link.rel = 'noopener noreferrer'; // Для безопасности
                                    link.style.textDecoration = 'none'; // Убрать подчеркивание
                                    fullNameCell.appendChild(link);
                                } else {
                                    // Если username нет, пытаемся создать ссылку tg://user?id=
                                    const tgLink = document.createElement('a');
                                    tgLink.href = `tg://user?id=${user.user_id}`;
                                    tgLink.textContent = user.full_name;
                                    // target='_blank' для tg:// ссылок обычно не нужен, но и не мешает
                                    tgLink.style.textDecoration = 'none';
                                    tgLink.style.color = 'inherit';
                                    // Можно добавить title, чтобы пользователь понимал, что ссылка откроется в приложении
                                    tgLink.title = 'Открыть профиль в Telegram';
                                    fullNameCell.appendChild(tgLink);
                                }
                                row.insertCell().textContent = user.username; // SQL уже обработал NULL
                                row.insertCell().textContent = user.actions_count;
                                row.insertCell().textContent = user.last_action_time;
                            });
                        }
                    }

                    if (data.popular_commands && Array.isArray(data.popular_commands)) {
                        if (data.popular_commands.length === 0) {
                            popularCommandsStatusElement.textContent = "Нет данных о командах для отображения.";
                            if (popularCommandsChartInstance) { popularCommandsChartInstance.destroy(); popularCommandsChartInstance = null; }
                        } else {
                            popularCommandsStatusElement.textContent = ""; // Очищаем статус, если есть данные
                            updatePopularCommandsChart(data.popular_commands);
                        }
                    }
                    
                    if (data.popular_messages && Array.isArray(data.popular_messages)) {
                        if (data.popular_messages.length === 0) {
                            popularMessagesStatusElement.textContent = "Нет данных о сообщениях для отображения.";
                            if (popularMessagesChartInstance) { popularMessagesChartInstance.destroy(); popularMessagesChartInstance = null; }
                        } else {
                            popularMessagesStatusElement.textContent = ""; // Очищаем статус
                            updatePopularMessagesChart(data.popular_messages);
                        }
                    }

                    if (data.action_types_distribution && Array.isArray(data.action_types_distribution)) {
                        if (data.action_types_distribution.length === 0) {
                            actionTypesStatusElement.textContent = "Нет данных о типах действий.";
                            if (actionTypesChartInstance) { actionTypesChartInstance.destroy(); actionTypesChartInstance = null; }
                        } else {
                            actionTypesStatusElement.textContent = "";
                            updateActionTypesChart(data.action_types_distribution);
                        }
                    }

                    if (data.activity_over_time && Array.isArray(data.activity_over_time)) {
                        if (data.activity_over_time.length === 0) {
                            activityOverTimeStatusElement.textContent = "Нет данных об активности для отображения.";
                            if (activityOverTimeChartInstance) { activityOverTimeChartInstance.destroy(); activityOverTimeChartInstance = null; }
                        } else {
                            activityOverTimeStatusElement.textContent = "";
                            updateActivityOverTimeChart(data.activity_over_time);
                        }
                    }

                } catch (e) {
                    console.error("Ошибка парсинга WebSocket данных:", e, "Данные:", event.data);
                    totalActionsValueElement.textContent = "Ошибка обработки данных";
                    leaderboardBodyElement.innerHTML = `<tr><td colspan="6" style="text-align:center;">Ошибка обработки данных.</td></tr>`;
                    popularCommandsStatusElement.textContent = "Ошибка обработки данных для графика.";
                    popularMessagesStatusElement.textContent = "Ошибка обработки данных для графика.";
                    actionTypesStatusElement.textContent = "Ошибка обработки данных для графика.";
                    activityOverTimeStatusElement.textContent = "Ошибка обработки данных для графика.";
                 }
            };
 
            statsSocket.onerror = function(error) {
                console.error("WebSocket ошибка:", error);
                totalActionsValueElement.textContent = "Ошибка соединения WebSocket";
                leaderboardBodyElement.innerHTML = `<tr><td colspan="6" style="text-align:center;">Ошибка соединения WebSocket.</td></tr>`;
                popularCommandsStatusElement.textContent = "Ошибка соединения WebSocket для графика.";
                popularMessagesStatusElement.textContent = "Ошибка соединения WebSocket для графика.";
                actionTypesStatusElement.textContent = "Ошибка соединения WebSocket для графика.";
                activityOverTimeStatusElement.textContent = "Ошибка соединения WebSocket для графика.";
                if (popularCommandsChartInstance) { popularCommandsChartInstance.destroy(); popularCommandsChartInstance = null; }
                if (popularMessagesChartInstance) { popularMessagesChartInstance.destroy(); popularMessagesChartInstance = null; }
                if (actionTypesChartInstance) { actionTypesChartInstance.destroy(); actionTypesChartInstance = null; }
                if (activityOverTimeChartInstance) { activityOverTimeChartInstance.destroy(); activityOverTimeChartInstance = null; }
            };

            statsSocket.onclose = function(event) {
                console.log("WebSocket соединение закрыто. Код:", event.code, "Причина:", event.reason);
                totalActionsValueElement.textContent = "Соединение потеряно. Попытка переподключения через 5с...";
                // Попытка переподключения через некоторое время
                leaderboardBodyElement.innerHTML = `<tr><td colspan="6" style="text-align:center;">Соединение потеряно. Попытка переподключения...</td></tr>`;
                popularCommandsStatusElement.textContent = "Соединение для графика потеряно. Попытка переподключения...";
                popularMessagesStatusElement.textContent = "Соединение для графика потеряно. Попытка переподключения...";
                actionTypesStatusElement.textContent = "Соединение для графика потеряно. Попытка переподключения...";
                activityOverTimeStatusElement.textContent = "Соединение для графика потеряно. Попытка переподключения...";
                if (popularCommandsChartInstance) { popularCommandsChartInstance.destroy(); popularCommandsChartInstance = null; }
                if (popularMessagesChartInstance) { popularMessagesChartInstance.destroy(); popularMessagesChartInstance = null; }
                if (actionTypesChartInstance) { actionTypesChartInstance.destroy(); actionTypesChartInstance = null; }
                if (activityOverTimeChartInstance) { activityOverTimeChartInstance.destroy(); activityOverTimeChartInstance = null; }
                setTimeout(connectWebSocket, 5000);
            };
        }

        function connectLogWebSocket() {
            logSocket = new WebSocket(logWsUrl);
            botLogContentElement.innerHTML = ''; // Очищаем при новом подключении
            botLogStatusElement.textContent = 'Подключение к логу...';

            logSocket.onopen = function(event) {
                console.log("Log WebSocket соединение установлено.");
                botLogStatusElement.textContent = 'Соединение с логом установлено. Ожидание данных...';
            };

            logSocket.onmessage = function(event) {
                const newLogEntry = document.createElement('div');
                newLogEntry.classList.add('log-entry');
                newLogEntry.style.lineHeight = '1.4'; // Немного увеличим межстрочный интервал для читаемости
                const logText = event.data;

                // Регулярное выражение для парсинга стандартной строки лога Python
                // Формат: %(asctime)s - %(levelname)s - %(name)s - %(module)s.%(funcName)s:%(lineno)d - %(message)s
                const logRegex = /^(\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2}) - (INFO|WARNING|ERROR|CRITICAL|DEBUG) - ([a-zA-Z0-9_.]+) - ([a-zA-Z0-9_<>.]+)\.([a-zA-Z0-9_<>]+):(\d+) - (.*)$/;
                const match = logText.match(logRegex);

                if (match) {
                    const [, timestamp, level, loggerName, moduleName, funcName, lineNo, message] = match;

                    const timestampSpan = document.createElement('span');
                    timestampSpan.textContent = timestamp + " ";
                    timestampSpan.classList.add('timestamp');

                    const levelSpan = document.createElement('span');
                    levelSpan.textContent = level;
                    levelSpan.classList.add('level', `level-${level.toLowerCase()}`);

                    const messageSpan = document.createElement('span');
                    messageSpan.textContent = `- ${loggerName} - ${moduleName}.${funcName}:${lineNo} - ${message}`;
                    messageSpan.classList.add('message', `message-${level.toLowerCase()}`);

                    // Specific styles not easily covered by pure CSS class inheritance (like background for critical)
                    // can still be applied or refined here if needed, or add more specific CSS classes.
                    // For now, the CSS classes should handle most of it.

                    newLogEntry.appendChild(timestampSpan);
                    newLogEntry.appendChild(levelSpan);
                    newLogEntry.appendChild(messageSpan);

                } else {
                    newLogEntry.textContent = logText;
                    // Add classes for unparsed errors/warnings for theming
                    if (logText.startsWith("ОШИБКА")) {
                        newLogEntry.classList.add('log-error-unparsed');
                    } else if (logText.startsWith("ПРЕДУПРЕЖДЕНИЕ:")) {
                        // Could add a .log-warning-unparsed if specific styling is needed
                    }
                }
                botLogContentElement.appendChild(newLogEntry);
                // Автопрокрутка вниз
                botLogContentElement.scrollTop = botLogContentElement.scrollHeight;
                if (botLogStatusElement.textContent.includes('Ожидание данных')) {
                    botLogStatusElement.textContent = ''; // Убираем сообщение об ожидании
                }
            };

            logSocket.onerror = function(error) {
                console.error("Log WebSocket ошибка:", error);
                botLogStatusElement.textContent = 'Ошибка соединения с логом WebSocket.';
                const errorEntry = document.createElement('div');
                errorEntry.textContent = `ОШИБКА СОЕДИНЕНИЯ: ${error}`;
                errorEntry.style.color = 'red';
                botLogContentElement.appendChild(errorEntry);
            };

            logSocket.onclose = function(event) {
                console.log("Log WebSocket соединение закрыто. Код:", event.code, "Причина:", event.reason);
                botLogStatusElement.textContent = 'Соединение с логом потеряно. Попытка переподключения через 5с...';
                setTimeout(connectLogWebSocket, 5000);
            };
        }
        // Начинаем подключение
        connectWebSocket();
        connectLogWebSocket();
     </script>

    <script>
        function getChartThemeColors(theme) {
            const isDark = theme === 'dark';
            return {
                tickColor: isDark ? 'rgba(255, 255, 255, 0.7)' : '#555',
                gridColor: isDark ? 'rgba(255, 255, 255, 0.15)' : 'rgba(0, 0, 0, 0.1)',
                legendColor: isDark ? 'rgba(255, 255, 255, 0.9)' : '#333',
                titleColor: isDark ? 'rgba(255, 255, 255, 0.9)' : '#333'
            };
        }

        function updatePopularCommandsChart(commandsData) {
            const ctx = document.getElementById('popularCommandsChart').getContext('2d');
            const labels = commandsData.map(item => item.command);
            const counts = commandsData.map(item => item.count);
            const currentTheme = document.documentElement.getAttribute('data-theme') || 'light';
            const themeColors = getChartThemeColors(currentTheme);

            const chartOptions = {
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                    y: {
                        beginAtZero: true,
                        ticks: { color: themeColors.tickColor },
                        grid: { color: themeColors.gridColor }
                    },
                    x: {
                        ticks: { color: themeColors.tickColor },
                        grid: { color: themeColors.gridColor, drawOnChartArea: false }
                    }
                },
                plugins: {
                    legend: {
                        labels: { color: themeColors.legendColor }
                    }
                }
            };

            if (popularCommandsChartInstance) {
                popularCommandsChartInstance.data.labels = labels;
                popularCommandsChartInstance.data.datasets[0].data = counts;
                Object.assign(popularCommandsChartInstance.options, chartOptions); // Update all options
                popularCommandsChartInstance.update();
            } else {
                popularCommandsChartInstance = new Chart(ctx, {
                    type: 'bar',
                    data: {
                        labels: labels,
                        datasets: [{
                            label: 'Количество вызовов',
                            data: counts,
                            backgroundColor: 'rgba(54, 162, 235, 0.5)',
                            borderColor: 'rgba(54, 162, 235, 1)',
                            borderWidth: 1
                        }]
                    },
                    options: chartOptions
                });
            }
        }

        function updatePopularMessagesChart(messagesData) {
            const ctx = document.getElementById('popularMessagesChart').getContext('2d');
            const labels = messagesData.map(item => item.message);
            const counts = messagesData.map(item => item.count);
            const currentTheme = document.documentElement.getAttribute('data-theme') || 'light';
            const themeColors = getChartThemeColors(currentTheme);

            const chartOptions = {
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                    y: {
                        beginAtZero: true,
                        ticks: { color: themeColors.tickColor },
                        grid: { color: themeColors.gridColor }
                    },
                    x: {
                        ticks: { color: themeColors.tickColor },
                        grid: { color: themeColors.gridColor, drawOnChartArea: false }
                    }
                },
                plugins: {
                    legend: { labels: { color: themeColors.legendColor } }
                }
            };

            if (popularMessagesChartInstance) {
                popularMessagesChartInstance.data.labels = labels;
                popularMessagesChartInstance.data.datasets[0].data = counts;
                Object.assign(popularMessagesChartInstance.options, chartOptions);
                popularMessagesChartInstance.update();
            } else {
                popularMessagesChartInstance = new Chart(ctx, {
                    type: 'bar', // Вертикальный бар-чарт
                    data: {
                        labels: labels,
                        datasets: [{
                            label: 'Количество сообщений',
                            data: counts,
                            backgroundColor: 'rgba(75, 192, 192, 0.5)',
                            borderColor: 'rgba(75, 192, 192, 1)',
                            borderWidth: 1
                        }]
                    },
                    options: chartOptions
                });
            }
        }

        function updateActionTypesChart(actionTypesData) {
            const ctx = document.getElementById('actionTypesChart').getContext('2d');
            const labels = actionTypesData.map(item => item.action_type);
            const counts = actionTypesData.map(item => item.count);
            const currentTheme = document.documentElement.getAttribute('data-theme') || 'light';
            const themeColors = getChartThemeColors(currentTheme);

            const chartOptions = {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: {
                        position: 'top',
                        labels: { color: themeColors.legendColor }
                    },
                    tooltip: {
                        callbacks: { /* existing callbacks */ }
                    }
                    // title: { display: true, text: 'Распределение типов действий', color: themeColors.titleColor } // Example title
                }
            };

            // Генерация случайных цветов для круговой диаграммы
            const backgroundColors = actionTypesData.map(() => 
                `rgba(${Math.floor(Math.random() * 255)}, ${Math.floor(Math.random() * 255)}, ${Math.floor(Math.random() * 255)}, 0.7)`);

            if (actionTypesChartInstance) {
                actionTypesChartInstance.data.labels = labels;
                actionTypesChartInstance.data.datasets[0].data = counts;
                actionTypesChartInstance.data.datasets[0].backgroundColor = backgroundColors;
                Object.assign(actionTypesChartInstance.options, chartOptions);
                actionTypesChartInstance.update();
            } else {
                actionTypesChartInstance = new Chart(ctx, {
                    type: 'pie', // Тип диаграммы - круговая
                    data: {
                        labels: labels,
                        datasets: [{
                            label: 'Распределение типов действий',
                            data: counts,
                            backgroundColor: backgroundColors,
                            hoverOffset: 4
                        }]
                    },
                    options: chartOptions
                });
            }
        }

        function updateActivityOverTimeChart(activityData) {
            const ctx = document.getElementById('activityOverTimeChart').getContext('2d');
            const labels = activityData.map(item => item.period);
            const counts = activityData.map(item => item.count);
            const currentTheme = document.documentElement.getAttribute('data-theme') || 'light';
            const themeColors = getChartThemeColors(currentTheme);

            const chartOptions = {
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                    y: {
                        beginAtZero: true,
                        ticks: { color: themeColors.tickColor },
                        grid: { color: themeColors.gridColor }
                    },
                    x: {
                        ticks: { color: themeColors.tickColor },
                        grid: { color: themeColors.gridColor, drawOnChartArea: true } // Grid lines for time axis can be useful
                    }
                },
                plugins: {
                    legend: {
                        labels: { color: themeColors.legendColor }
                    }
                }
            };

            if (activityOverTimeChartInstance) {
                activityOverTimeChartInstance.data.labels = labels;
                activityOverTimeChartInstance.data.datasets[0].data = counts;
                Object.assign(activityOverTimeChartInstance.options, chartOptions);
                activityOverTimeChartInstance.update();
            } else {
                activityOverTimeChartInstance = new Chart(ctx, {
                    type: 'line', // Тип графика - линейный
                    data: {
                        labels: labels,
                        datasets: [{
                            label: 'Количество действий',
                            data: counts,
                            fill: false, // Не заполнять область под линией
                            borderColor: 'rgb(255, 99, 132)', // Цвет линии
                            tension: 0.1 // Сглаживание линии
                        }]
                    },
                    options: chartOptions
                });
            }
        }

        function openTab(evt, tabName) {
            var i, tabcontent, tablinks;
            // Скрываем все элементы с классом "tab-content"
            tabcontent = document.getElementsByClassName("tab-content");
            for (i = 0; i < tabcontent.length; i++) {
                tabcontent[i].style.display = "none";
            }
            // Удаляем класс "active" у всех кнопок с классом "tab-button"
            tablinks = document.getElementsByClassName("tab-button");
            for (i = 0; i < tablinks.length; i++) {
                tablinks[i].className = tablinks[i].className.replace(" active", "");
            }
            // Показываем текущую вкладку и добавляем класс "active" к кнопке, открывшей вкладку
            document.getElementById(tabName).style.display = "block";
            evt.currentTarget.className += " active";

            // Может потребоваться перерисовка графиков при открытии вкладки, если они не отображаются корректно
        }

        // Логика переключения темы
        const themeToggleButton = document.getElementById('theme-toggle-button');
        
        function applyTheme(theme) {
            document.documentElement.setAttribute('data-theme', theme);
            localStorage.setItem('theme', theme);
            if (theme === 'dark') {
                themeToggleButton.textContent = 'Светлая тема';
            } else {
                themeToggleButton.textContent = 'Темная тема';
            }

            const newThemeColors = getChartThemeColors(theme);
            Chart.defaults.color = newThemeColors.legendColor; // General text color for charts (legends, tooltips)
            Chart.defaults.borderColor = newThemeColors.gridColor; // Default for grid lines

            // Update existing charts
            [popularCommandsChartInstance, popularMessagesChartInstance, actionTypesChartInstance, activityOverTimeChartInstance].forEach(chart => {
                if (chart) {
                    const chartSpecificOptions = getChartThemeColors(theme); // Get fresh theme colors
                    if (chart.options.scales) {
                        if (chart.options.scales.x) {
                            if(chart.options.scales.x.ticks) chart.options.scales.x.ticks.color = chartSpecificOptions.tickColor;
                            if(chart.options.scales.x.grid) chart.options.scales.x.grid.color = chartSpecificOptions.gridColor;
                        }
                        if (chart.options.scales.y) {
                            if(chart.options.scales.y.ticks) chart.options.scales.y.ticks.color = chartSpecificOptions.tickColor;
                            if(chart.options.scales.y.grid) chart.options.scales.y.grid.color = chartSpecificOptions.gridColor;
                        }
                    }
                    if (chart.options.plugins && chart.options.plugins.legend && chart.options.plugins.legend.labels) {
                        chart.options.plugins.legend.labels.color = chartSpecificOptions.legendColor;
                    }
                    if (chart.options.plugins && chart.options.plugins.title && chart.options.plugins.title.display) {
                        chart.options.plugins.title.color = chartSpecificOptions.titleColor;
                    }
                    chart.update();
                }
            });
        }

        // Initial theme setup
        let storedTheme = localStorage.getItem('theme');
        if (!storedTheme || (storedTheme !== 'light' && storedTheme !== 'dark')) {
            storedTheme = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light';
        }
        applyTheme(storedTheme); // Apply stored or preferred theme on load

        themeToggleButton.addEventListener('click', function() {
            let theme = document.documentElement.getAttribute('data-theme');
            theme = (theme === 'dark') ? 'light' : 'dark';
            applyTheme(theme);
        });
    </script>
 </body>
 </html>
